{"version":3,"file":"js/bundle.731423139ded64f25dbe.min.js","mappings":"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","sources":["webpack:///../node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js","webpack:///../node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js","webpack:///../node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js","webpack:///../node_modules/@ffmpeg/ffmpeg/src/browser/index.js","webpack:///../node_modules/@ffmpeg/ffmpeg/src/config.js","webpack:///../node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js","webpack:///../node_modules/@ffmpeg/ffmpeg/src/index.js","webpack:///../node_modules/@ffmpeg/ffmpeg/src/utils/log.js","webpack:///../node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js","webpack:///../node_modules/@ffmpeg/ffmpeg/src/utils/parseProgress.js","webpack:///../node_modules/resolve-url/resolve-url.js"],"sourcesContent":["const resolveURL = require('resolve-url');\nconst { devDependencies } = require('../../package.json');\n\n/*\n * Default options for browser environment\n */\nmodule.exports = {\n  corePath: process.env.NODE_ENV === 'development'\n    ? resolveURL('/node_modules/@ffmpeg/core/dist/ffmpeg-core.js')\n    : `https://unpkg.com/@ffmpeg/core@${devDependencies['@ffmpeg/core'].substring(1)}/dist/ffmpeg-core.js`,\n};\n","const resolveURL = require('resolve-url');\n\nconst readFromBlobOrFile = (blob) => (\n  new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n      resolve(fileReader.result);\n    };\n    fileReader.onerror = ({ target: { error: { code } } }) => {\n      reject(Error(`File could not be read! Code=${code}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n  })\n);\n\nmodule.exports = async (_data) => {\n  let data = _data;\n  if (typeof _data === 'undefined') {\n    return new Uint8Array();\n  }\n\n  if (typeof _data === 'string') {\n    /* From base64 format */\n    if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(_data)) {\n      data = atob(_data.split(',')[1])\n        .split('')\n        .map((c) => c.charCodeAt(0));\n    /* From remote server/URL */\n    } else {\n      const res = await fetch(resolveURL(_data));\n      data = await res.arrayBuffer();\n    }\n  /* From Blob or File */\n  } else if (_data instanceof File || _data instanceof Blob) {\n    data = await readFromBlobOrFile(_data);\n  }\n\n  return new Uint8Array(data);\n};\n","/* eslint-disable no-undef */\nconst resolveURL = require('resolve-url');\nconst { log } = require('../utils/log');\n\n/*\n * Fetch data from remote URL and convert to blob URL\n * to avoid CORS issue\n */\nconst toBlobURL = async (url, mimeType) => {\n  log('info', `fetch ${url}`);\n  const buf = await (await fetch(url)).arrayBuffer();\n  log('info', `${url} file size = ${buf.byteLength} bytes`);\n  const blob = new Blob([buf], { type: mimeType });\n  const blobURL = URL.createObjectURL(blob);\n  log('info', `${url} blob URL = ${blobURL}`);\n  return blobURL;\n};\n\nmodule.exports = async ({ corePath: _corePath }) => {\n  if (typeof _corePath !== 'string') {\n    throw Error('corePath should be a string!');\n  }\n  const coreRemotePath = resolveURL(_corePath);\n  const corePath = await toBlobURL(\n    coreRemotePath,\n    'application/javascript',\n  );\n  const wasmPath = await toBlobURL(\n    coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.wasm'),\n    'application/wasm',\n  );\n  const workerPath = await toBlobURL(\n    coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.worker.js'),\n    'application/javascript',\n  );\n  if (typeof createFFmpegCore === 'undefined') {\n    return new Promise((resolve) => {\n      const script = document.createElement('script');\n      const eventHandler = () => {\n        script.removeEventListener('load', eventHandler);\n        log('info', 'ffmpeg-core.js script loaded');\n        resolve({\n          createFFmpegCore,\n          corePath,\n          wasmPath,\n          workerPath,\n        });\n      };\n      script.src = corePath;\n      script.type = 'text/javascript';\n      script.addEventListener('load', eventHandler);\n      document.getElementsByTagName('head')[0].appendChild(script);\n    });\n  }\n  log('info', 'ffmpeg-core.js script is loaded already');\n  return Promise.resolve({\n    createFFmpegCore,\n    corePath,\n    wasmPath,\n    workerPath,\n  });\n};\n","const defaultOptions = require('./defaultOptions');\nconst getCreateFFmpegCore = require('./getCreateFFmpegCore');\nconst fetchFile = require('./fetchFile');\n\nmodule.exports = {\n  defaultOptions,\n  getCreateFFmpegCore,\n  fetchFile,\n};\n","module.exports = {\n  defaultArgs: [\n    /* args[0] is always the binary path */\n    './ffmpeg',\n    /* Disable interaction mode */\n    '-nostdin',\n    /* Force to override output file */\n    '-y',\n  ],\n  baseOptions: {\n    /* Flag to turn on/off log messages in console */\n    log: false,\n    /*\n     * Custom logger to get ffmpeg.wasm output messages.\n     * a sample logger looks like this:\n     *\n     * ```\n     * logger = ({ type, message }) => {\n     *   console.log(type, message);\n     * }\n     * ```\n     *\n     * type can be one of following:\n     *\n     * info: internal workflow debug messages\n     * fferr: ffmpeg native stderr output\n     * ffout: ffmpeg native stdout output\n     */\n    logger: () => {},\n    /*\n     * Progress handler to get current progress of ffmpeg command.\n     * a sample progress handler looks like this:\n     *\n     * ```\n     * progress = ({ ratio }) => {\n     *   console.log(ratio);\n     * }\n     * ```\n     *\n     * ratio is a float number between 0 to 1.\n     */\n    progress: () => {},\n    /*\n     * Path to find/download ffmpeg.wasm-core,\n     * this value should be overwriten by `defaultOptions` in\n     * each environment.\n     */\n    corePath: '',\n  },\n};\n","const { defaultArgs, baseOptions } = require('./config');\nconst { setLogging, setCustomLogger, log } = require('./utils/log');\nconst parseProgress = require('./utils/parseProgress');\nconst parseArgs = require('./utils/parseArgs');\nconst { defaultOptions, getCreateFFmpegCore } = require('./node');\nconst { version } = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: logging,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options,\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let running = false;\n  let progress = optProgress;\n  const detectCompletion = (message) => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n  const parseMessage = ({ type, message }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */\n      const {\n        createFFmpegCore,\n        corePath,\n        workerPath,\n        wasmPath,\n      } = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: corePath,\n        printErr: (message) => parseMessage({ type: 'fferr', message }),\n        print: (message) => parseMessage({ type: 'ffout', message }),\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined') {\n            if (typeof wasmPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.wasm')) {\n              return wasmPath;\n            }\n            if (typeof workerPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.worker.js')) {\n              return workerPath;\n            }\n          }\n          return prefix + path;\n        },\n      });\n      ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve) => {\n        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);\n        runResolve = resolve;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n  const exit = () => {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      running = false;\n      Core.exit(1);\n      Core = null;\n      ffmpeg = null;\n      runResolve = null;\n    }\n  };\n\n  const setProgress = (_progress) => {\n    progress = _progress;\n  };\n\n  const setLogger = (_logger) => {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n\n  log('info', `use ffmpeg.wasm v${version}`);\n\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    exit,\n    FS,\n  };\n};\n","require('regenerator-runtime/runtime');\nconst createFFmpeg = require('./createFFmpeg');\nconst { fetchFile } = require('./node');\n\nmodule.exports = {\n  /*\n   * Create ffmpeg instance.\n   * Each ffmpeg instance owns an isolated MEMFS and works\n   * independently.\n   *\n   * For example:\n   *\n   * ```\n   * const ffmpeg = createFFmpeg({\n   *  log: true,\n   *  logger: () => {},\n   *  progress: () => {},\n   *  corePath: '',\n   * })\n   * ```\n   *\n   * For the usage of these four arguments, check config.js\n   *\n   */\n  createFFmpeg,\n  /*\n   * Helper function for fetching files from various resource.\n   * Sometimes the video/audio file you want to process may located\n   * in a remote URL and somewhere in your local file system.\n   *\n   * This helper function helps you to fetch to file and return an\n   * Uint8Array variable for ffmpeg.wasm to consume.\n   *\n   */\n  fetchFile,\n};\n","let logging = false;\nlet customLogger = () => {};\n\nconst setLogging = (_logging) => {\n  logging = _logging;\n};\n\nconst setCustomLogger = (logger) => {\n  customLogger = logger;\n};\n\nconst log = (type, message) => {\n  customLogger({ type, message });\n  if (logging) {\n    console.log(`[${type}] ${message}`);\n  }\n};\n\nmodule.exports = {\n  logging,\n  setLogging,\n  setCustomLogger,\n  log,\n};\n","module.exports = (Core, args) => {\n  const argsPtr = Core._malloc(args.length * Uint32Array.BYTES_PER_ELEMENT);\n  args.forEach((s, idx) => {\n    const buf = Core._malloc(s.length + 1);\n    Core.writeAsciiToMemory(s, buf);\n    Core.setValue(argsPtr + (Uint32Array.BYTES_PER_ELEMENT * idx), buf, 'i32');\n  });\n  return [args.length, argsPtr];\n};\n","let duration = 0;\nlet ratio = 0;\n\nconst ts2sec = (ts) => {\n  const [h, m, s] = ts.split(':');\n  return (parseFloat(h) * 60 * 60) + (parseFloat(m) * 60) + parseFloat(s);\n};\n\nmodule.exports = (message, progress) => {\n  if (typeof message === 'string') {\n    if (message.startsWith('  Duration')) {\n      const ts = message.split(', ')[0].split(': ')[1];\n      const d = ts2sec(ts);\n      progress({ duration: d, ratio });\n      if (duration === 0 || duration > d) {\n        duration = d;\n      }\n    } else if (message.startsWith('frame') || message.startsWith('size')) {\n      const ts = message.split('time=')[1].split(' ')[0];\n      const t = ts2sec(ts);\n      ratio = t / duration;\n      progress({ ratio, time: t });\n    } else if (message.startsWith('video:')) {\n      progress({ ratio: 1 });\n      duration = 0;\n    }\n  }\n};\n","// Copyright 2014 Simon Lydell\r\n// X11 (“MIT”) Licensed. (See LICENSE.)\r\n\r\nvoid (function(root, factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    define(factory)\r\n  } else if (typeof exports === \"object\") {\r\n    module.exports = factory()\r\n  } else {\r\n    root.resolveUrl = factory()\r\n  }\r\n}(this, function() {\r\n\r\n  function resolveUrl(/* ...urls */) {\r\n    var numUrls = arguments.length\r\n\r\n    if (numUrls === 0) {\r\n      throw new Error(\"resolveUrl requires at least one argument; got none.\")\r\n    }\r\n\r\n    var base = document.createElement(\"base\")\r\n    base.href = arguments[0]\r\n\r\n    if (numUrls === 1) {\r\n      return base.href\r\n    }\r\n\r\n    var head = document.getElementsByTagName(\"head\")[0]\r\n    head.insertBefore(base, head.firstChild)\r\n\r\n    var a = document.createElement(\"a\")\r\n    var resolved\r\n\r\n    for (var index = 1; index < numUrls; index++) {\r\n      a.href = arguments[index]\r\n      resolved = a.href\r\n      base.href = resolved\r\n    }\r\n\r\n    head.removeChild(base)\r\n\r\n    return resolved\r\n  }\r\n\r\n  return resolveUrl\r\n\r\n}));\r\n"],"names":["devDependencies","module","exports","corePath","substring","resolveURL","async","_data","data","Uint8Array","test","atob","split","map","c","charCodeAt","res","fetch","arrayBuffer","File","Blob","blob","Promise","resolve","reject","fileReader","FileReader","onload","result","onerror","target","error","code","Error","readAsArrayBuffer","log","toBlobURL","url","mimeType","buf","byteLength","type","blobURL","URL","createObjectURL","_corePath","coreRemotePath","wasmPath","replace","workerPath","createFFmpegCore","script","document","createElement","eventHandler","removeEventListener","src","addEventListener","getElementsByTagName","appendChild","defaultOptions","getCreateFFmpegCore","fetchFile","defaultArgs","baseOptions","logger","progress","setLogging","setCustomLogger","parseProgress","parseArgs","version","NO_LOAD","_options","logging","optProgress","options","Core","ffmpeg","runResolve","running","parseMessage","message","detectCompletion","setProgress","_progress","setLogger","_logger","load","mainScriptUrlOrBlob","printErr","print","locateFile","path","prefix","window","endsWith","cwrap","isLoaded","run","_args","join","args","filter","s","length","exit","FS","method","arg","ret","e","createFFmpeg","customLogger","_logging","console","argsPtr","_malloc","Uint32Array","BYTES_PER_ELEMENT","forEach","idx","writeAsciiToMemory","setValue","duration","ratio","ts2sec","ts","h","m","parseFloat","startsWith","d","t","time","numUrls","arguments","base","href","head","insertBefore","firstChild","resolved","a","index","removeChild"],"sourceRoot":""}