/**
 * 
 * @param {sting} str ( rgba(0,0,0,0), rgb(0,0,0), #000000, #00000000, #000 or #0000 )
 */
function str2rgba(str) {
  var colorStr = str.toLowerCase();
  var color;

  if (colorStr.substring(0, 3) === 'rgb') {
    // rgb[a](0, 0, 0[, 0]) format.
    var matches = /^rgba?\s*\((\d+),\s*(\d+),\s*(\d+)([^)]*)\)$/.exec(colorStr);
    color = {
      r: matches[1] / 255,
      g: matches[2] / 255,
      b: matches[3] / 255,
      a: 1.0
    };

    if (matches[4]) {
      color.a = parseFloat(/^,\s*(.*)$/.exec(matches[4])[1]);
    }
  } else {
    // Hex digit format.
    if (colorStr.charAt(0) === '#') {
      colorStr = colorStr.substr(1);
    }

    if (colorStr.length === 3) {
      colorStr = colorStr.replace(/^(.)(.)(.)$/, '$1$1$2$2$3$3');
    }

    if (colorStr.length === 4) {
      colorStr = colorStr.replace(/^(.)(.)(.)(.)$/, '$1$1$2$2$3$3$4$4');
    }

    color = {
      r: parseInt(colorStr.substr(0, 2), 16) / 255,
      g: parseInt(colorStr.substr(2, 2), 16) / 255,
      b: parseInt(colorStr.substr(4, 2), 16) / 255,
      a: 1.0
    };

    if (colorStr.length === 8) {
      color.a = parseInt(colorStr.substr(6, 2), 16) / 255;
    }
  }

  return color;
}

/**
 * 
 * @param {object} rgba object {"r":1,"g":1,"b":1,"a":1}
 */
function rgba2hsla(_ref) {
  var r = _ref.r,
      g = _ref.g,
      b = _ref.b,
      a = _ref.a;
  var min = Math.min(r, g, b);
  var max = Math.max(r, g, b);
  var delta = max - min;
  var h, s, l;

  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }

  h = Math.min(h * 60, 360);

  if (h < 0) {
    h += 360;
  }

  l = (min + max) / 2;

  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }

  s = s * 100;
  l = l * 100;
  return {
    h: h,
    s: s,
    l: l,
    a: a
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function rgb2hsl(rgb) {
  var _rgba2hsla = rgba2hsla(_objectSpread2(_objectSpread2({}, rgb), {}, {
    a: 1
  })),
      h = _rgba2hsla.h,
      s = _rgba2hsla.s,
      l = _rgba2hsla.l;

  return {
    h: h,
    s: s,
    l: l
  };
}

function hsla2rgba(_ref) {
  var h = _ref.h,
      s = _ref.s,
      l = _ref.l,
      a = _ref.a;
  var r, g, b, m, c, x;
  if (!isFinite(h)) h = 0;
  if (!isFinite(s)) s = 0;
  if (!isFinite(l)) l = 0;
  h /= 60;
  if (h < 0) h = 6 - -h % 6;
  h %= 6;
  s = Math.max(0, Math.min(1, s / 100));
  l = Math.max(0, Math.min(1, l / 100));
  c = (1 - Math.abs(2 * l - 1)) * s;
  x = c * (1 - Math.abs(h % 2 - 1));

  if (h < 1) {
    r = c;
    g = x;
    b = 0;
  } else if (h < 2) {
    r = x;
    g = c;
    b = 0;
  } else if (h < 3) {
    r = 0;
    g = c;
    b = x;
  } else if (h < 4) {
    r = 0;
    g = x;
    b = c;
  } else if (h < 5) {
    r = x;
    g = 0;
    b = c;
  } else {
    r = c;
    g = 0;
    b = x;
  }

  m = l - c / 2;
  r = r + m;
  g = g + m;
  b = b + m;
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}

function hsl2rgb(hsl) {
  var _hsla2rgba = hsla2rgba(_objectSpread2(_objectSpread2({}, hsl), {}, {
    a: 1
  })),
      r = _hsla2rgba.r,
      g = _hsla2rgba.g,
      b = _hsla2rgba.b;

  return {
    r: r,
    g: g,
    b: b
  };
}

function rgba2hex(_ref) {
  var r = _ref.r,
      g = _ref.g,
      b = _ref.b,
      a = _ref.a;
  return '#' + (r * 255 | 1 << 8).toString(16).slice(1) + (g * 255 | 1 << 8).toString(16).slice(1) + (b * 255 | 1 << 8).toString(16).slice(1) + (a * 255 | 1 << 8).toString(16).slice(1);
}

function rgb2hex(rgb) {
  return rgba2hex(_objectSpread2(_objectSpread2({}, rgb), {}, {
    a: 1
  })).slice(0, 7);
}

// http://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html#key-terms
// Calculating Ratio
function contrast(l1, l2) {
  return (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
}

// http://www.w3.org/WAI/GL/wiki/Relative_luminance
// Calculating Luminance from r g b, a values
function relativeLuminance(_ref) {
  var r = _ref.r,
      g = _ref.g,
      b = _ref.b,
      a = _ref.a;

  var _map = [r, g, b].map(function (c) {
    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }),
      _map2 = _slicedToArray(_map, 3),
      rl = _map2[0],
      gl = _map2[1],
      bl = _map2[2];

  return (0.2126 * rl + 0.7152 * gl + 0.0722 * bl) * a;
}

var ratios = {
  'min-ratio-3': {
    description: '(WCAG AA, large text)',
    minRatio: 3
  },
  'min-ratio-4.5': {
    description: '(WCAG AA, normal text / WCAG AAA, large text)',
    minRatio: 4.5
  },
  'min-ratio-7': {
    description: '(WCAG AAA, normal text)',
    minRatio: 7
  },
  'AA-large': {
    description: '(WCAG AA, large text)',
    minRatio: 3
  },
  'AA': {
    description: '(WCAG AA, normal text)',
    minRatio: 4.5
  },
  'AAA': {
    description: '(WCAG AAA, normal text)',
    minRatio: 7
  }
};

function aa(ratio) {
  var txtSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;
  var verbose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  // If the ratio is 4.5 and above, it passes AA.
  if (ratio >= 3 && txtSize >= 18) {
    // large-size font AA pass
    if (verbose) console.log(ratios['min-ratio-3']);
    return true;
  } else if (ratio >= 4.5) {
    // normal-size font AA pass
    if (verbose) console.log(ratios['min-ratio-4.5']);
    return true;
  }

  return false;
}

function aaa(ratio) {
  var txtSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;
  var verbose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  // If the ratio is 7 and above, it passes AAA.
  if (ratio >= 4.5 && txtSize >= 18) {
    // large-size font AAA pass
    if (verbose) console.log(ratios['min-ratio-4.5']);
    return true;
  } else if (ratio >= 7) {
    // normal-size font AAA pass
    if (verbose) console.log(ratios['min-ratio-7']);
    return true;
  }

  return false;
}

function hslaVector3(_ref, v3) {
  var h = _ref.h,
      s = _ref.s,
      l = _ref.l,
      a = _ref.a;
  var hv = v3[0];
  var sv = v3[1];
  var lv = v3[2];
  var h1 = (h + hv) % 360;

  if (h1 < 0) {
    h1 += 360;
  }

  var s1 = Math.min(Math.max(s + sv, 0), 100); // caping 0, 100;

  var l1 = Math.min(Math.max(l + lv, 0), 100); // caping 0, 100;

  return {
    h: h1,
    s: s1,
    l: l1,
    a: a
  };
}

var THRESHOLD = 0.1; // experimental 

/**
 * 
 * @param {object} color {rgba object}
 * @param {object} background {rgba object}
 * @param {number} ratio exemple: 4.5
 */

function getAccesibleHexColor(rgba, background, ratio) {
  var result = rgba;
  var r; // contrast ratio

  do {
    result = hsla2rgba(hslaVector3(rgba2hsla(result), [0, 0, THRESHOLD]) // vector3
    ); // to get a consistant Accesible hex value str2rgba( rgba2hex(result)).

    r = contrast(relativeLuminance(str2rgba(rgba2hex(result))), relativeLuminance(background));
  } while (Math.round(r * 100) / 100 <= ratio);

  return result;
}

export { aa, aaa, contrast, getAccesibleHexColor, hsl2rgb, hsla2rgba, hslaVector3, ratios, relativeLuminance, rgb2hex, rgb2hsl, rgba2hex, rgba2hsla, str2rgba };
