/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const e="https://media3p.googleapis.com",t={LIST_MEDIA:"/v1/media",LIST_CATEGORIES:"/v1/categories",REGISTER_USAGE:"/v1/media:registerUsage"},a={RELEVANCE:"relevance",LATEST:"latest"},r={TRENDING:"trending"};function n(e,t){if(!(null==t||Object.values(e).indexOf(t.toLowerCase())>-1))throw new Error("Invalid order_by: "+t)}function l(e){if(!(null==e||e>0))throw new Error("Invalid page_size: "+e)}var s=new class ApiFetcher{async listMedia(){let{languageCode:e=null,filter:r=null,orderBy:s=null,pageSize:i=null,pageToken:o=null}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};await function(e){n(a,e)}(s),await l(i);const h=new URLSearchParams([["language_code",e],["filter",r],["order_by",s],["page_size",i],["page_token",o]].filter((e=>Boolean(e[1]))));return this.fetchPath({params:h,path:t.LIST_MEDIA})}async listCategories(){let{filter:e=null,orderBy:a=null,pageSize:s=null}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};await function(e){n(r,e)}(a),await l(s);const i=new URLSearchParams([["filter",e],["order_by",a],["page_size",s]].filter((e=>Boolean(e[1]))));return this.fetchPath({params:i,path:t.LIST_CATEGORIES})}async registerUsage(e){let{registerUsageUrl:a}=e;await function(e){if(!e||!e.includes(t.REGISTER_USAGE))throw new Error("Invalid url: "+e)}(a),await this.fetchUrl({url:new URL(a),method:"POST"})}fetchPath(e){let{path:t,params:a,method:r}=e;const n=new URL("https://media3p.googleapis.com"+t);return a.forEach(((e,t)=>{n.searchParams.append(t,e)})),this.fetchUrl({url:n,method:r})}async fetchUrl(e){let{url:t,method:a}=e;t.searchParams.append("key","AIzaSyDqgPsZ0VnxAuakmX7bjnzmNQsE7Drlvk0");const r=await window.fetch(t.href,{method:a??"GET"});if(!r.ok)throw new Error("Obtained an error from the "+t.pathname+" call, statusCode: "+r.status+", statusText: "+r.statusText);return r.json()}};export{e as API_DOMAIN,t as Paths,s as default};
