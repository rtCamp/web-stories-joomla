/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import{useReduction as t}from"@googleforcreators/react";import e from"./insertStop.js";import o from"./regenerateColor.js";import{TYPE_SOLID as r,TYPE_RADIAL as n,TYPE_LINEAR as s}from"./constants.js";const p={type:r,regenerate:!1,stops:[],currentColor:{r:0,g:0,b:0,a:0},currentStopIndex:0,rotation:.5,alpha:1,center:{x:.5,y:.5},size:{w:1,h:1}},a={load:(t,e)=>{let{payload:o}=e;const{type:p,color:a,stops:c,rotation:l,center:i,size:u,alpha:d}=o,g=p&&p!==r&&(t.type!==p||c?.length!==t.stops?.length)?{currentColor:c[0].color,currentStopIndex:0}:{};switch(p){case s:return{...t,...g,type:p,regenerate:!1,stops:c,alpha:isNaN(d)?t.alpha:d,rotation:isNaN(l)?0:l};case n:return{...t,...g,type:p,regenerate:!1,stops:c,center:void 0!==i?i:t.center,size:void 0!==u?u:t.size,alpha:isNaN(d)?t.alpha:d};default:return{...t,type:r,regenerate:!1,currentColor:a}}},setToSolid:t=>({...t,type:r,regenerate:!0}),setToGradient:(t,e)=>{let{payload:o}=e;const r=t.stops&&t.stops.length>=2?t.stops:[{color:t.currentColor,position:0},{color:t.currentColor,position:1}];return{...t,regenerate:!0,type:o,stops:r}},addStopAt:(t,o)=>{let{payload:r}=o;if(r=Number(r.toFixed(2)),t.stops.some((t=>{let{position:e}=t;return e===r})))return t;const{index:n,color:s}=e(t.stops,r),p=[...t.stops.slice(0,n),{color:s,position:r},...t.stops.slice(n)];return{...t,regenerate:!0,currentColor:s,currentStopIndex:n,stops:p}},moveCurrentStopBy:(t,e)=>{let{payload:o}=e;const r=t.currentStopIndex,n=t.stops[r].position,s=Math.max(0,Math.min(1,Number((n+o).toFixed(2))));if(s===n)return t;const p=[...t.stops.slice(0,r),{...t.stops[r],position:s},...t.stops.slice(r+1)];p.sort(((t,e)=>t.position-e.position));const a=p.findIndex((t=>{let{position:e}=t;return e===s}));return{...t,regenerate:!0,stops:p,currentStopIndex:a}},removeCurrentStop:t=>{if(2===t.stops.length)return t;const e=t.currentStopIndex,o=[...t.stops];o.splice(e,1);const r=e===o.length?e-1:e;return{...t,regenerate:!0,stops:o,currentColor:o[r].color,currentStopIndex:r}},updateCurrentColor:(t,e)=>{let{payload:{rgb:o}}=e;const n={...o},s={...t,regenerate:!0,currentColor:n};return t.type!==r&&(s.stops=[...t.stops.slice(0,t.currentStopIndex),{...t.stops[t.currentStopIndex],color:n},...t.stops.slice(t.currentStopIndex+1)]),s},rotateClockwise:t=>({...t,rotation:(t.rotation+.25)%1,regenerate:!0}),selectStop:(t,e)=>{let{payload:o}=e;const r=Math.max(0,Math.min(t.stops.length-1,o)),n=t.stops[r].color;return{...t,currentStopIndex:r,currentColor:n}},reverseStops:t=>{const e=t.stops.map((t=>{let{color:e,position:o}=t;return{color:e,position:1-o}})).reverse(),o=e.length-t.currentStopIndex-1;return{...t,stops:e,currentStopIndex:o,regenerate:!0}}};function c(){const[e,r]=t(p,a),n=o(e);return{state:{...e,generatedColor:n},actions:r}}export{c as default};
