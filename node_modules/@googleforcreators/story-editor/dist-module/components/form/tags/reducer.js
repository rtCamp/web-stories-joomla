/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import{clamp as e}from"@googleforcreators/units";import t from"../../../utils/cleanForSlug.js";function a(e){return e.replace(/( +)/g," ").trim()}function s(e){const a=new Map;return e.forEach((e=>{a.set(t(e),e)})),[...a.values()]}function n(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.length===t.length&&e.every((e=>t.includes(e)))}const r={UPDATE_VALUE:"updateValue",SUBMIT_VALUE:"submitValue",REMOVE_TAG:"removeTag",RESET_OFFSET:"resetOffset",RESET_VALUE:"resetValue",INCREMENT_OFFSET:"incrementOffset",DECREMENT_OFFSET:"decrementOffset",UPDATE_TAGS:"updateTags"};function l(l,u){switch(u.type){case r.UPDATE_VALUE:{const e=u.payload.split(",");if(e.length<=1)return{...l,value:u.payload};const t=e.slice(0,-1).map(a).filter((e=>e.length)),n=e[e.length-1];return function(){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]).forEach((t=>e.includes(t)))}(t,l.tags)?{...l,value:n}:{...l,value:n,tagBuffer:s([...l.tags.slice(0,l.tags.length-l.offset),...t,...l.tags.slice(l.tags.length-l.offset)])}}case r.SUBMIT_VALUE:{const e=a(u?.payload||l.value);return""===e||l.tags.includes(e)?{...l,value:""}:{...l,value:"",tagBuffer:s([...l.tags.slice(0,l.tags.length-l.offset),e,...l.tags.slice(l.tags.length-l.offset)])}}case r.REMOVE_TAG:{const e="string"==typeof u.payload?l.tags.findIndex((e=>e===u.payload)):l.tags.length-1-l.offset;return e<0?l:{...l,tagBuffer:[...l.tags.slice(0,e),...l.tags.slice(e+1,l.tags.length)]}}case r.INCREMENT_OFFSET:return{...l,offset:e(l.offset+1,{MIN:0,MAX:l.tags.length})};case r.DECREMENT_OFFSET:return{...l,offset:e(l.offset-1,{MIN:0,MAX:l.tags.length})};case r.RESET_OFFSET:return{...l,offset:0};case r.RESET_VALUE:return{...l,value:""};case r.UPDATE_TAGS:{const e=l.tags.map((e=>[t(e),e])),a=u.payload.map((e=>[t(e),e]));if(n(e.map((e=>{let[t]=e;return t})),a.map((e=>{let[t]=e;return t}))))return l;const s=e.filter((e=>{let[t]=e;return a.map((e=>{let[t]=e;return t})).includes(t)})).map((e=>{let[,t]=e;return t})),r=a.filter((t=>{let[a]=t;return!e.map((e=>{let[t]=e;return t})).includes(a)})).map((e=>{let[,t]=e;return t}));return{...l,tags:[...s,...r],tagBuffer:null}}default:return l}}export{r as ACTIONS,n as deepEquals,l as default};
