/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

"use strict";var e=require("@googleforcreators/react"),t=require("./insertStop.js"),r=require("./regenerateColor.js"),o=require("./constants.js");const s={type:o.TYPE_SOLID,regenerate:!1,stops:[],currentColor:{r:0,g:0,b:0,a:0},currentStopIndex:0,rotation:.5,alpha:1,center:{x:.5,y:.5},size:{w:1,h:1}},n={load:(e,t)=>{let{payload:r}=t;const{type:s,color:n,stops:p,rotation:c,center:a,size:i,alpha:l}=r,u=s&&s!==o.TYPE_SOLID&&(e.type!==s||p?.length!==e.stops?.length)?{currentColor:p[0].color,currentStopIndex:0}:{};switch(s){case o.TYPE_LINEAR:return{...e,...u,type:s,regenerate:!1,stops:p,alpha:isNaN(l)?e.alpha:l,rotation:isNaN(c)?0:c};case o.TYPE_RADIAL:return{...e,...u,type:s,regenerate:!1,stops:p,center:void 0!==a?a:e.center,size:void 0!==i?i:e.size,alpha:isNaN(l)?e.alpha:l};case o.TYPE_SOLID:default:return{...e,type:o.TYPE_SOLID,regenerate:!1,currentColor:n}}},setToSolid:e=>({...e,type:o.TYPE_SOLID,regenerate:!0}),setToGradient:(e,t)=>{let{payload:r}=t;const o=e.stops&&e.stops.length>=2?e.stops:[{color:e.currentColor,position:0},{color:e.currentColor,position:1}];return{...e,regenerate:!0,type:r,stops:o}},addStopAt:(e,r)=>{let{payload:o}=r;if(o=Number(o.toFixed(2)),e.stops.some((e=>{let{position:t}=e;return t===o})))return e;const{index:s,color:n}=t(e.stops,o),p=[...e.stops.slice(0,s),{color:n,position:o},...e.stops.slice(s)];return{...e,regenerate:!0,currentColor:n,currentStopIndex:s,stops:p}},moveCurrentStopBy:(e,t)=>{let{payload:r}=t;const o=e.currentStopIndex,s=e.stops[o].position,n=Math.max(0,Math.min(1,Number((s+r).toFixed(2))));if(n===s)return e;const p=[...e.stops.slice(0,o),{...e.stops[o],position:n},...e.stops.slice(o+1)];p.sort(((e,t)=>e.position-t.position));const c=p.findIndex((e=>{let{position:t}=e;return t===n}));return{...e,regenerate:!0,stops:p,currentStopIndex:c}},removeCurrentStop:e=>{if(2===e.stops.length)return e;const t=e.currentStopIndex,r=[...e.stops];r.splice(t,1);const o=t===r.length?t-1:t;return{...e,regenerate:!0,stops:r,currentColor:r[o].color,currentStopIndex:o}},updateCurrentColor:(e,t)=>{let{payload:{rgb:r}}=t;const s={...r},n={...e,regenerate:!0,currentColor:s};return e.type!==o.TYPE_SOLID&&(n.stops=[...e.stops.slice(0,e.currentStopIndex),{...e.stops[e.currentStopIndex],color:s},...e.stops.slice(e.currentStopIndex+1)]),n},rotateClockwise:e=>({...e,rotation:(e.rotation+.25)%1,regenerate:!0}),selectStop:(e,t)=>{let{payload:r}=t;const o=Math.max(0,Math.min(e.stops.length-1,r)),s=e.stops[o].color;return{...e,currentStopIndex:o,currentColor:s}},reverseStops:e=>{const t=e.stops.map((e=>{let{color:t,position:r}=e;return{color:t,position:1-r}})).reverse(),r=t.length-e.currentStopIndex-1;return{...e,stops:t,currentStopIndex:r,regenerate:!0}}};module.exports=function(){const[t,o]=e.useReduction(s,n),p=r(t);return{state:{...t,generatedColor:p},actions:o}};
