/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@googleforcreators/units"),t=require("../../../utils/cleanForSlug.js");function s(e){return e.replace(/( +)/g," ").trim()}function a(e){const s=new Map;return e.forEach((e=>{s.set(t(e),e)})),[...s.values()]}function r(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.length===t.length&&e.every((e=>t.includes(e)))}const l={UPDATE_VALUE:"updateValue",SUBMIT_VALUE:"submitValue",REMOVE_TAG:"removeTag",RESET_OFFSET:"resetOffset",RESET_VALUE:"resetValue",INCREMENT_OFFSET:"incrementOffset",DECREMENT_OFFSET:"decrementOffset",UPDATE_TAGS:"updateTags"};exports.ACTIONS=l,exports.deepEquals=r,exports.default=function(n,u){switch(u.type){case l.UPDATE_VALUE:{const e=u.payload.split(",");if(e.length<=1)return{...n,value:u.payload};const t=e.slice(0,-1).map(s).filter((e=>e.length)),r=e[e.length-1];return function(){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]).forEach((t=>e.includes(t)))}(t,n.tags)?{...n,value:r}:{...n,value:r,tagBuffer:a([...n.tags.slice(0,n.tags.length-n.offset),...t,...n.tags.slice(n.tags.length-n.offset)])}}case l.SUBMIT_VALUE:{const e=s(u?.payload||n.value);return""===e||n.tags.includes(e)?{...n,value:""}:{...n,value:"",tagBuffer:a([...n.tags.slice(0,n.tags.length-n.offset),e,...n.tags.slice(n.tags.length-n.offset)])}}case l.REMOVE_TAG:{const e="string"==typeof u.payload?n.tags.findIndex((e=>e===u.payload)):n.tags.length-1-n.offset;return e<0?n:{...n,tagBuffer:[...n.tags.slice(0,e),...n.tags.slice(e+1,n.tags.length)]}}case l.INCREMENT_OFFSET:return{...n,offset:e.clamp(n.offset+1,{MIN:0,MAX:n.tags.length})};case l.DECREMENT_OFFSET:return{...n,offset:e.clamp(n.offset-1,{MIN:0,MAX:n.tags.length})};case l.RESET_OFFSET:return{...n,offset:0};case l.RESET_VALUE:return{...n,value:""};case l.UPDATE_TAGS:{const e=n.tags.map((e=>[t(e),e])),s=u.payload.map((e=>[t(e),e]));if(r(e.map((e=>{let[t]=e;return t})),s.map((e=>{let[t]=e;return t}))))return n;const a=e.filter((e=>{let[t]=e;return s.map((e=>{let[t]=e;return t})).includes(t)})).map((e=>{let[,t]=e;return t})),l=s.filter((t=>{let[s]=t;return!e.map((e=>{let[t]=e;return t})).includes(s)})).map((e=>{let[,t]=e;return t}));return{...n,tags:[...a,...l],tagBuffer:null}}default:return n}};
